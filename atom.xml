<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lalalala</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-20T04:18:46.090Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Super Shiro</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c-第7章 函数与模块化程序设计</title>
    <link href="http://example.com/2022/10/16/c-%E7%AC%AC7%E7%AB%A0-%E5%87%BD%E6%95%B0%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2022/10/16/c-%E7%AC%AC7%E7%AB%A0-%E5%87%BD%E6%95%B0%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-10-16T09:37:46.000Z</published>
    <updated>2022-10-20T04:18:46.090Z</updated>
    
    <content type="html"><![CDATA[<h3 id="7-1分而治之与信息隐藏"><a href="#7-1分而治之与信息隐藏" class="headerlink" title="7.1分而治之与信息隐藏"></a>7.1分而治之与信息隐藏</h3><p>·将大问题分解成小问题，即分而治之<br>模块化程序设计体现了该功能<br>·函数是c语言模块化程序设计中的最小单元<br>·将函数的内容隐藏起来，使程序的结构更加紧凑逻辑更加清晰，这就是所谓的信息隐藏</p><h3 id="7-2函数的定义"><a href="#7-2函数的定义" class="headerlink" title="7.2函数的定义"></a>7.2函数的定义</h3><h4 id="7-2-1-函数的分类"><a href="#7-2-1-函数的分类" class="headerlink" title="7.2.1 函数的分类"></a>7.2.1 函数的分类</h4><p>①标准库函数：符合ANSI C标准的c语言编辑器都必须提供这些库函数（printf（）、scanf（））等等<br>使用ANSI C的库函数，必须在程序的开头把该函数所在的头文件包含进来即&lt;stdio.h&gt;<br>②自定义函数：自行编写函数来完成自己所需要的功能，即自定义函数</p><h4 id="7-2-2-函数的定义"><a href="#7-2-2-函数的定义" class="headerlink" title="7.2.2 函数的定义"></a>7.2.2 函数的定义</h4><p>·函数定义的基本格式为：<br>返回值类型 函数名（类型 形参1，类型 形参2……）{<br>    声明语句序列<br>    可执行语句序列\被称为函数体<br>}//→函数的定界符<br>·函数名是函数的唯一标识，用于说明函数的功能，一般使用英文单词及其组合，通常变量名用小写字母开头的单词组合，函数名用大写字母开头的单词组合而成<br>·在函数题内定义的变量只能在函数体内访问，称为内部变量</p><p>·若函数没有返回值，则定义函数的类型为void，如果函数不需要入口参数，则用void来代替形参的内容。最好在函数定义后面添加注释来告知函数功能及其形参</p><h3 id="7-3向函数传递值和函数返回值"><a href="#7-3向函数传递值和函数返回值" class="headerlink" title="7.3向函数传递值和函数返回值"></a>7.3向函数传递值和函数返回值</h3><h4 id="7-3-1函数调用"><a href="#7-3-1函数调用" class="headerlink" title="7.3.1函数调用"></a>7.3.1函数调用</h4><p>·有返回值的函数必须要有return语句,retrun语句用来指明函数将返回给主调函数的值是什么。无论函数在什么位置，只要执行到它，就立即返回到函数的调用者。<br>·函数的返回值只能有一个，函数的返回值的类型可以是除数组以外的任何类型。函数可以有多个<br>return语句（if-else选择结构）,但这并不意味着函数可以返回多个值。<br>·当函数的返回值为void类型的时候，表明函数没有返回值，如果没有return函数执行到最后一条语句才返回，如果希望函数可以在中途返回，那么必须使用return语句返回，无需任何返回值的函数可写为retrun；<br>·main（）函数，定义main函数的时候没有表明返回值类型，也未使用void，择期返回值一般被默认为int类型</p><h4 id="7-3-2函数原型"><a href="#7-3-2函数原型" class="headerlink" title="7.3.2函数原型"></a>7.3.2函数原型</h4><p>·可以将函数体放在main函数之前，也可以放在后面<br>如何放在后面？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please enter the n:&quot;</span>);</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="type">int</span> result = Fact(n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, result);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">result *= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·函数原型声明必须放在main（）之前</p><h4 id="7-3-3函数封装与防御性程序设计"><a href="#7-3-3函数封装与防御性程序设计" class="headerlink" title="7.3.3函数封装与防御性程序设计"></a>7.3.3函数封装与防御性程序设计</h4><p>·用户所使用的的ASCI C标准库函数，在内部定义的哪些变量使用了哪些算法细节用户看不到，这就是函数封装<br>·为了使自定义函数具有遇到不正确使用或者非法数据输入时能保护自己避免出错的能力，即增强程序的健壮性，需要在函数的入口处增加对函数参数合法性的调查，称为防御性编程<br>·所以自定义函数需要增加对入口参数合法化的检查和对函数返回值的检验<br>·printf虽然作用是输出值，但实际上也有返回值，如果没有加入return，可能会把printf的返回值作为函数的输出值，其值为输出的字符个数<br>可以考虑在main函数内对入口参数合法化的检查</p><h4 id="7-3-4函数设计的基本原则"><a href="#7-3-4函数设计的基本原则" class="headerlink" title="7.3.4函数设计的基本原则"></a>7.3.4函数设计的基本原则</h4><p>·如果某一功能重复实现三次以上，则应当考虑写成函数。（p171）</p><h3 id="7-4函数的递归调用和递归函数"><a href="#7-4函数的递归调用和递归函数" class="headerlink" title="7.4函数的递归调用和递归函数"></a>7.4函数的递归调用和递归函数</h3><p>一个递归函数必须包含如下两个部分：<br>①由其自身定义的与原始问题类似的更小规模的子问题，能使递归过程持续进行，称为一般情况<br>②递归调用的最简形式，它是一个能够用来结束递归调用过程的条件，通常称为基线情况<br>·一般来说，如果能直接写出上一项和下一项的通式，结合if条件判断，可以解决问题，或是直接return函数。</p><p>·在函数中直接或间接地调用自己的函数调用，就称为递归调用，这样的函数称为递归函数<br>为了提高程序的执行效率，尽量用迭代形式替代递归形式。</p><h3 id="7-5变量的作用域和生存期"><a href="#7-5变量的作用域和生存期" class="headerlink" title="7.5变量的作用域和生存期"></a>7.5变量的作用域和生存期</h3><h4 id="7-5-1变量的作用域"><a href="#7-5-1变量的作用域" class="headerlink" title="7.5.1变量的作用域"></a>7.5.1变量的作用域</h4><p>·程序中被花括号括起来的区域，称为语句块。函数体是语句块，分支语句和循环体也是语句块。变量的作用域规则是，每个变量仅在定义它的语句块内有效，并且拥有自己的存储空间。<br>·不在任何语句块内定义的变量，称为全局变量。在除了整个程序以外的其它语句内定义的变量，称为局部变量。故函数体内的变量发生变化时，无法带入main函数中。<br>·全局变量定义在头文件以下。</p><h4 id="7-5-2变量的生存期"><a href="#7-5-2变量的生存期" class="headerlink" title="7.5.2变量的生存期"></a>7.5.2变量的生存期</h4><p>·变量只能在生存期内被访问，而变量的作用域也会影响变量的生存期，因此，c语言中提供的存储类型主要有以下集中<br>①自动变量；②静态变量；③外部变量；④寄存器变量</p><p>1.自动变量<br>·自动变量的标准定义格式为<br> auto 类型名 变量名；<br> 例如：auto int temp；<br> 如果没有指定变量的存储类型，那么变量的存储类型就缺省为auto。<br> ·自动变量的自动体现在进入语句块的时候自动申请内存，退出语句块释放内存。它仅能被语句块内的语句访问，在退出语句块以后不能再访问，因此，自动变量也成为动态局部变量<br> ·自动变量在每次定义的时候都需要初始化</p><p> 2.静态变量<br> ·一个自动变量在退出定义它的函数后，因系统给它分配的内存已经被释放，下次再进入该函数时，系统会重新给它分配内存，因此它的值是不会保留的。所以这个时候要用到静态变量。用static关键字定义的变量称为静态变量。静态变量的定义格式为：<br> static 类型名 变量名；</p><p>·静态局部变量在循环体内作用相当于函数，外部的同名变量不进入循环体内运算，只有内部的进行运算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> i;</span><br><span class="line">i*=i;</span><br><span class="line">&#125;<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br></pre></td></tr></table></figure><p>最后输出的i还是1；</p><p> 3.外部变量<br> 外部变量就是全局变量，它的作用域就是在它的定义点到本文件的末尾。如果需要在定义点之前或者在其它文件中使用它，就需要用关键字extern对其进行声明（与其他变量不相同的是，声明不是定义，编译器并不为其分配内存），格式为<br> extern 类型名 变量名<br>·没有显式初始化的外部变量由编译程序自动初始化为0.<br>·与静态变量相似的是，它们的生存期都是整个程序运行期间。即从程序运行起就占据内存，程序推出才释放内存。但是它们的作用域可能不同，在函数内定义的静态变量，称为静态局部变量，静态局部变量只能在定义它的函数内被访问，而在所有函数外定义的静态变量，称为静态全局变量，<br><em>静态全局变量可以在定义它的文件内被访问，但不能像非静态的全局变量能够被程序的其它文件访问</em><br>·定义之时不能赋值</p><p>4.寄存器变量<br>其定义格式为：<br>register 类型名 变量名；<br>将使用频率较高的变量声明为register，可以避免cpu对存储器的频繁数据访问，使得程序更小，执行数据更快。现代编译器一般对普通变量有所优化，故一般无须特别声明变量为register</p><h3 id="7-6模块化程序设计"><a href="#7-6模块化程序设计" class="headerlink" title="7.6模块化程序设计"></a>7.6模块化程序设计</h3><p>·一般地，把需要共享的函数放在一个单独的.c文件中，把共享函数的函数原型、宏定义和全局变量声明等放在一个单独的.h头文件中，其他需要共享这个函数的程序用#include包含这个头文件后，就可以调用这个函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;7-1分而治之与信息隐藏&quot;&gt;&lt;a href=&quot;#7-1分而治之与信息隐藏&quot; class=&quot;headerlink&quot; title=&quot;7.1分而治之与信息隐藏&quot;&gt;&lt;/a&gt;7.1分而治之与信息隐藏&lt;/h3&gt;&lt;p&gt;·将大问题分解成小问题，即分而治之&lt;br&gt;模块化程序设计体现</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构第一章</title>
    <link href="http://example.com/2022/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>http://example.com/2022/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2022-10-16T08:06:22.000Z</published>
    <updated>2022-10-20T11:50:35.178Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-1-1关于数据组织"><a href="#1-1-1关于数据组织" class="headerlink" title="1.1.1关于数据组织"></a>1.1.1关于数据组织</h3><p>·解决问题方法的效率和数据的组织方式有关</p><h3 id="1-1-2关于空间使用"><a href="#1-1-2关于空间使用" class="headerlink" title="1.1.2关于空间使用"></a>1.1.2关于空间使用</h3><p>·一个例子，建立一个函数PrintfN,实现传入正整数N，可以打印1到N的全部正整数。<br>有两种方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintN</span><span class="params">(<span class="type">int</span> N)</span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintN</span><span class="params">(<span class="type">int</span> N)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(N)&#123;</span><br><span class="line">PrintN(N<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,N);<span class="comment">//N必定会是最后一个输出的，只要N大于0就能够继续执行程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·递归的占据空间比循环的大，当N的数值过大的时候，递归程序可能直接罢工<br>·结局问题方法的效率和空间的利用效率有关。</p><h3 id="1-1-3关于算法效率"><a href="#1-1-3关于算法效率" class="headerlink" title="1.1.3关于算法效率"></a>1.1.3关于算法效率</h3><p>·pow函数的计算效率比较低，一般不在循环中使用<br>·clock():捕捉从程序开始运行到clock()被调用所耗费的时间，这个时间单位是clock tick，即“时钟打点”。<br>·常数CLK_TCK，机器时钟每秒所走的时钟打点数。<br>用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1e7<span class="comment">//被测函数最大调用次数</span></span></span><br><span class="line"><span class="type">clock_t</span> star,stop;</span><br><span class="line"><span class="comment">//clock_t是clock函数返回的变量类型；</span></span><br><span class="line"><span class="type">double</span> duration;</span><br><span class="line"><span class="comment">//记录被测函数运行时间，以秒为单位；不在测试范围内的准备工作全部写在主函数之前。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">star=clock();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;MAX;i++)&#123;</span><br><span class="line">MyFuntion();</span><br><span class="line">&#125;</span><br><span class="line">    stop=clock();</span><br><span class="line">    duration=((<span class="type">double</span>)(stop-star))/CLK_TCK/MAX；</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ticks=%f\n&quot;</span>,((<span class="type">double</span>)(stop-starts)));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;duration=%6.2f&quot;</span>,duration);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·如果duration的输出为0，说明函数太快了，没有到一个tick的时间，就无法打点，（这也是为什么多次循环可以找到一个tick的时间，但是单词循环找不到的原因）这样的话就需要重复多次运行函数，再除max，可以得到单次的时间。<br>·解决问题方法的效率和算法的巧妙程度有关。</p><h3 id="1-1-4抽象数据类型"><a href="#1-1-4抽象数据类型" class="headerlink" title="1.1.4抽象数据类型"></a>1.1.4抽象数据类型</h3><pre><code>·数据对象集①数据对象集；②数据集合相关联的操作集·描述数据类型的方法不依赖于具体实现①与存放数据的机器无关②与数据存储的物理结构无关③与实现操作的算法和编程语言无关</code></pre><p>总的来说：只关心“是什么”不关心“怎么做”</p><h3 id="1-2-1算法的定义"><a href="#1-2-1算法的定义" class="headerlink" title="1.2.1算法的定义"></a>1.2.1算法的定义</h3><p>·一个有限的指令集<br>·接受一下输入(有些情况下不会有输入)<br>·产生输出<br>·一定在有限步骤之中终止<br>每一条指令必须：<br>①有充分的目标，不可以有歧义<br>②计算机能够处理的范围之内<br>③描述应不依赖于任何一种计算机语言以及具体实现的手段</p><p>·不关心具体实现的细节（用什么语言，什么方法实现）<br>所以说算法更像是一串伪代码？</p><h3 id="1-2-2什么是好的算法"><a href="#1-2-2什么是好的算法" class="headerlink" title="1.2.2什么是好的算法"></a>1.2.2什么是好的算法</h3><p>衡量标准：<br>①空间复杂度S(n)：根据算法写成的程序在执行时所占用储存单元的长度。<br>②时间复杂度T(n)：根据算法写成的程序在执行时耗费的时间的长度。<br>·时间复杂度，在比较上可以根据做了几次的相同的运算，比如乘法的次数</p><p>在分析一般算法的效率的时候，我们经常关注以下两种复杂度<br>最坏情况复杂度：T(worst)(n)<br>平均复杂度：T（avg)(n)//worst avg是下标<br>·由于平均复杂难以计算，一般用最坏情况复杂度来衡量</p><h3 id="1-2-3复杂度的渐进表示"><a href="#1-2-3复杂度的渐进表示" class="headerlink" title="1.2.3复杂度的渐进表示"></a>1.2.3复杂度的渐进表示</h3><p>·T(n)=O(f(n))表示存在常数C&gt;0,n&gt;n0,使得当n&gt;=n0时有，T(n)&lt;=C* f(n),即O(f(n)))表示f(n)是T(n)的某种上界<br>·T(n)=Ω(g(n))表示存在常数C&gt;0,n&gt;n0,使得当n&gt;=n0时有，T(n)&gt;=C* g(n),即Ω(g(n)))表示g(n)是T(n)的某种下界<br>·T(n)=θ(h(n))表示同时有T(n)=O(h(n))和T(n)=O(h(n)),即θ既是上界也是下界。</p><p>·分析小窍门<br>若两端算法分别有复杂度T1(n)=O(f1(n))和T2(n)=O(f1(n))，则:<br>·T1(n)+T2(n)=max(T1(n),T2(n))<br>·T1(n)* T2(n)=O(f1(n)×f2(n))<br>·若T(n)是关于n的k阶多项式，那么T(n)=θ(pow(n,k))<br>·一个for循环的时间复杂度等于循环次数乘以循环体代码的复杂度<br>·if-else 结构的复杂度取决于if的条件判断复杂度和两个<br>分支部分的复杂度，总体复杂度取三者中最大。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-1-1关于数据组织&quot;&gt;&lt;a href=&quot;#1-1-1关于数据组织&quot; class=&quot;headerlink&quot; title=&quot;1.1.1关于数据组织&quot;&gt;&lt;/a&gt;1.1.1关于数据组织&lt;/h3&gt;&lt;p&gt;·解决问题方法的效率和数据的组织方式有关&lt;/p&gt;
&lt;h3 id=&quot;1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c-第6章-循环控制结构</title>
    <link href="http://example.com/2022/10/15/c-%E7%AC%AC6%E7%AB%A0-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2022/10/15/c-%E7%AC%AC6%E7%AB%A0-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</id>
    <published>2022-10-15T11:38:57.000Z</published>
    <updated>2022-10-15T15:52:18.480Z</updated>
    
    <content type="html"><![CDATA[<h3 id="6-1循环控制结构与循环语句"><a href="#6-1循环控制结构与循环语句" class="headerlink" title="6.1循环控制结构与循环语句"></a>6.1循环控制结构与循环语句</h3><p>·循环结构通常有两种类型：①当型循环结构：先做判断后做循环，直到不符合循环条件，循环结束。<br>②直到型循环结构：先做循环后做判断，不符合循环条件，循环结束。<br>·三大循环语句：for循环；while循环；do while循环<br>·在for和while的括号后面加上“；”可能会导致死循环。<br>·for while 和while最大的差别就是当条件为假的时候，do while至少会做一次循环内容。</p><h3 id="6-2计数控制的循环"><a href="#6-2计数控制的循环" class="headerlink" title="6.2计数控制的循环"></a>6.2计数控制的循环</h3><p>·如果需要输出多个循环过程的值，优先考虑一个用一个循环条件来输出<br>·计数控制的循环至少需要定义三个变脸，求值变量，输入变量和计数变量</p><h3 id="6-3嵌套循环"><a href="#6-3嵌套循环" class="headerlink" title="6.3嵌套循环"></a>6.3嵌套循环</h3><p>·三种循环体之间可以相互嵌套</p><h3 id="6-4条件控制的循环"><a href="#6-4条件控制的循环" class="headerlink" title="6.4条件控制的循环"></a>6.4条件控制的循环</h3><p>·随机函数rand用法(类似getchar)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用前需要包括:#include stdilb.h</span></span><br><span class="line"><span class="type">int</span> magic;</span><br><span class="line">magic=rand();</span><br></pre></td></tr></table></figure><p>·标准c规定RAND_MAX的值不大于双字节整数的最大值32767，也就是说rand()生成的值是一个在0-32767之间的整数。<br>·故可以利用以下方法来控制计算机生成的随机数的取值范围。<br>①rand()%b可以将生成的随机数变化在[0,b-1] (数字越大，能取余的数就越多)<br>②利用rand()%b+a将随机数范围平移到[a,a+b-1]</p><p>·但是每次运行函数，rand()所生成的随机数是一个伪随机数，其随机数序列是一样的。<br>故可以配合函数srand来设置随机数，例如，设置随机数种子srand为1，srand(1)<br>随机数种子发生变化则随机数序列会发生变化。    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">unsigned</span> seed;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please enter seed:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>,seed);</span><br><span class="line">srand(seed);</span><br><span class="line"><span class="type">int</span> magic;</span><br><span class="line">magic=rand()%<span class="number">100</span>+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>·如果不想每次都输入随机数种子来完成初始化，可以利用函数time()读取计算机的时钟值，并把该值设置为随机数种子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srand(time(<span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure><p>time返回以秒计算的日历时间，从一个标准时间点到当前时刻经过的相对时间，使用NULL作为time()的参数时候，time(NULL)返回一个无符号整数，则可以作为随机数发生器的种子。使用函数time()时候，必须在程序开头将头文件&lt;time.h&gt;包含到程序中。</p><p>·因为函数scanf()有缓存区，当输入非法字符（要求的类型与输入的类型不符合），scanf会直接跳过，该输入及不会被接受也不会被清除，被存放在scanf的缓存区，当下次调用scanf函数时，会直接从缓存区读取非法字符，造成死循环。<br>·解决方法：清除滞留在scanf缓存区的数据，使下一次循环时scanf可以正常的读取用户输入。<br>getchar可以避免单个字符的错乱，但是输入多个字符的时候，多出的字符仍然会造成多余的循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getchar()清除非法字符的方法。</span></span><br><span class="line"><span class="type">int</span> guess ,ret;</span><br><span class="line">ret=<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;guess);</span><br><span class="line"><span class="keyword">while</span>(ret!=<span class="number">1</span>)&#123;<span class="comment">//ret返回值是固定的，如果是数字是1</span></span><br><span class="line"><span class="keyword">while</span>(getchar()!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please guess a magic number&quot;</span>);</span><br><span class="line">ret=<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;guess);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·补充：猜数游戏最终版（生成随机数猜每次可以猜10次，可以选择继续，能够排除单个字符大小的非法变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> magic,guess,counter=<span class="number">0</span>;</span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line">magic = rand()%<span class="number">100</span>+<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">char</span> reply;</span><br><span class="line">  <span class="keyword">do</span>&#123;counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please guess a magic number:&quot;</span>);</span><br><span class="line">ret=<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;guess);</span><br><span class="line"><span class="keyword">while</span> (ret != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please guess a magic number:&quot;</span>);</span><br><span class="line">ret = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;guess);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (guess &lt; magic) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Wrong!too small\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (guess &gt; magic) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Wrong!too big\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Right!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">counter++;</span><br><span class="line">&#125; <span class="keyword">while</span> (guess != magic&amp;&amp;counter&lt;<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;magic is %d\n&quot;</span>, magic);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;do you want to continue(Y/N)or(y/n)?&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;reply);</span><br><span class="line">  &#125; <span class="keyword">while</span> (reply != <span class="string">&#x27;n&#x27;</span> || reply != <span class="string">&#x27;N&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### <span class="number">6.5</span>流程的转移控制</span><br><span class="line">#### <span class="number">6.5</span><span class="number">.1</span><span class="keyword">goto</span>语句</span><br><span class="line">·<span class="keyword">goto</span>语句可以向上向下跳转，但良好的编程应当尽可能少使用<span class="keyword">goto</span>语句</span><br><span class="line">```c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (c) &#123;</span><br><span class="line"><span class="keyword">goto</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;实例1\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;实例2\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;实例3\n&quot;</span>);</span><br><span class="line">start:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;实例4\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;实例5\n&quot;</span>);</span><br><span class="line">&#125;<span class="comment">//输出结果为实例4\n实例5</span></span><br></pre></td></tr></table></figure><p>·goto大多数运用在跳出循环，代替多个break跳出循环</p><h4 id="6-5-2break语句"><a href="#6-5-2break语句" class="headerlink" title="6.5.2break语句"></a>6.5.2break语句</h4><p>·break和沟通的语句都可以用于终止整个循环的执行，二者最大的区别就是，goto可以跳转到任意位置，而break只能跳转到当前所在循环语句的下一条语句去。</p><h4 id="6-5-3continue语句"><a href="#6-5-3continue语句" class="headerlink" title="6.5.3continue语句"></a>6.5.3continue语句</h4><p>·continue的语句：当在循环体中遇到continue的时候，程序将跳过continue语句后面尚未执行的语句，开始下一次循环。<br>但是同样的，continue语句与break一样只能对包含它们的最内层的循环语句起作用。</p><h4 id="6-5-4穷举法编程举例"><a href="#6-5-4穷举法编程举例" class="headerlink" title="6.5.4穷举法编程举例"></a>6.5.4穷举法编程举例</h4><p>·可设置一个标志变量find，当find为0(假)，则!find为真，可以用于做循环的条件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;6-1循环控制结构与循环语句&quot;&gt;&lt;a href=&quot;#6-1循环控制结构与循环语句&quot; class=&quot;headerlink&quot; title=&quot;6.1循环控制结构与循环语句&quot;&gt;&lt;/a&gt;6.1循环控制结构与循环语句&lt;/h3&gt;&lt;p&gt;·循环结构通常有两种类型：①当型循环结构：先</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c-第5章-选择控制结构</title>
    <link href="http://example.com/2022/09/16/c-%E7%AC%AC5%E7%AB%A0-%E9%80%89%E6%8B%A9%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2022/09/16/c-%E7%AC%AC5%E7%AB%A0-%E9%80%89%E6%8B%A9%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</id>
    <published>2022-09-16T07:02:17.000Z</published>
    <updated>2022-10-15T11:33:52.579Z</updated>
    
    <content type="html"><![CDATA[<h3 id="5-1算法的概念及其描述方法"><a href="#5-1算法的概念及其描述方法" class="headerlink" title="5.1算法的概念及其描述方法"></a>5.1算法的概念及其描述方法</h3><h4 id="5-1-1算法的概念"><a href="#5-1-1算法的概念" class="headerlink" title="5.1.1算法的概念"></a>5.1.1算法的概念</h4><p>·注明的计算机科学家沃思曾提出一个经典公式<br>数据结构+算法=程序<br>·数据结构是计算机储存、组织数据的方式，指相互之间存在一种或多种数据元素的集合<br>·算法是对操作或行为（即操作步骤）的描述。算法中包括数值算法与非数值算法。<br>·算法的五个基本特性<br>①有穷性：算法的操作步骤是有限的，且每一步都能在一定的时间内完成。<br>②确定性：算法的每一个步骤都是确定的，不允许有歧义。<br>③有效性：算法的每一个步骤都能有效执行并且能够得到确定的结果。<br>④允许没有或者多个输入<br>⑤必须要有一个或多个输出</p><h4 id="5-2关系运算符与关系表达式"><a href="#5-2关系运算符与关系表达式" class="headerlink" title="5.2关系运算符与关系表达式"></a>5.2关系运算符与关系表达式</h4><p>·c中的关系运算符及其优先级<br>！<a href="%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%8A%E5%85%B6%E4%BC%98%E5%85%88%E7%BA%A7">1</a><br>·用关系运算符将两个操作数连接起来组成的表达式，称为关系表达式<br>在c里面用非0值表示“真”，用0表示“假”</p><p>·算术运算符的优先级大于关系运算符</p><h4 id="5-3用于单分支控制的条件语句"><a href="#5-3用于单分支控制的条件语句" class="headerlink" title="5.3用于单分支控制的条件语句"></a>5.3用于单分支控制的条件语句</h4><p>·单分支控制的条件语句，他的本质要么符合条件，执行if内的语句，要么不符合条件直接跳过。<br>·判断变量是否=0，if()内的左值最好为0，易于纠错。</p><h4 id="5-4用于双分支控制的条件语句"><a href="#5-4用于双分支控制的条件语句" class="headerlink" title="5.4用于双分支控制的条件语句"></a>5.4用于双分支控制的条件语句</h4><p>·双分支控制的条件语句，本质是要么执行一条语句，要么执行另外一条语句。</p><h4 id="5-5条件运算符和条件表达式"><a href="#5-5条件运算符和条件表达式" class="headerlink" title="5.5条件运算符和条件表达式"></a>5.5条件运算符和条件表达式</h4><p>·在一定情况下可以替代if else，它的表达式如下：<br>表达式1？表达式2：表达式3；<br>若表达式1成立，则执行表达式2，否则表达式3。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int x,y;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;x,&amp;y);</span><br><span class="line">int max;</span><br><span class="line">max=x&gt;y?x:y;</span><br></pre></td></tr></table></figure><h4 id="5-6用于多分支控制的条件语句"><a href="#5-6用于多分支控制的条件语句" class="headerlink" title="5.6用于多分支控制的条件语句"></a>5.6用于多分支控制的条件语句</h4><p>·本质是有多个分支可供选择，用if else if 联系起来，末尾还需else。<br>如果末尾没有else，即if(){}else if(){}else if(){},本质上是多个单分支控制的条件语句串联，其并部位多分支控制的条件语句。</p><h5 id="fabs-函数的用法及浮点数"><a href="#fabs-函数的用法及浮点数" class="headerlink" title="fabs()函数的用法及浮点数"></a>fabs()函数的用法及浮点数</h5><p>·C语言中fabs()函数是返回某一个值的绝对值的一个函数,fabs函数输出的只能是float、double类型的数值。通常fabs函数用于浮点数的大小比较，因为浮点数在计算机的二进制中可能存在误差，故在使用fabs函数需要以下的方法来判断。(需要调用math.h头文件)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①判断浮点数是否相等，<span class="keyword">if</span>(<span class="built_in">fabs</span>(a-b)&lt;=<span class="number">1E-6</span>)<span class="comment">//只能用近似的方法将实数与0进行比较，判断是否近似为0，只能判断某数的绝对值是否小于或等于一个很小的数EPS 1e-6，这也是为什么判断浮点数等于0方式相同。</span></span><br><span class="line">②判断浮点数是否等于<span class="number">0</span>，<span class="keyword">if</span>(<span class="built_in">fabs</span>(a)&lt;=<span class="number">1E-6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//以及浮点数和0的大小比较应与EPS 1e-6</span></span><br></pre></td></tr></table></figure><p>·为什么浮点数需要这么来判断？<br>这是因为浮点数在转换为二进制数的时候，不断乘以2，但计算机在表示一个数的时候，域宽是有限的，故会存在精度缺失。<a href="https://t.doruo.cn/9NhLM6bK">什么是浮点数？</a></p><p>·10进制小数如何转换为2进制小数<br>逆向思考，2进制小数，每个分位<em>2</em>e-n，得到10进制小数，10进制小数/(2*e-n),即，每乘一次2得到的整数部分就是第几次的小数位。</p><h5 id="exit-函数"><a href="#exit-函数" class="headerlink" title="exit()函数"></a>exit()函数</h5><p>·需要调用stdlib.h头文件<br>exit(0)//结束程序</p><h4 id="5-7用于多路选择的switch语句"><a href="#5-7用于多路选择的switch语句" class="headerlink" title="5.7用于多路选择的switch语句"></a>5.7用于多路选择的switch语句</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(a)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:<span class="number">4</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·Switch用于多路选择，类似于一系列的if-else语句，Switch后的表达式只能是char型或者int型，123即为对应的a输入的char型或者int型表达式，default常常用于处理非法输入。<br>·如果a是char型数值，case后面只能是字符’’,注意要用字符表示。</p><h4 id="5-8逻辑运算符和逻辑表达式"><a href="#5-8逻辑运算符和逻辑表达式" class="headerlink" title="5.8逻辑运算符和逻辑表达式"></a>5.8逻辑运算符和逻辑表达式</h4><p>·在c里，用1表示表达式的值为真，用0表达表达式的值为假，且关系运算符具有左结合性。例如对于：a&lt;b&lt;c，若a&lt;b为真，则为1&lt;c，若1&gt;c，则输出为0。</p><p>·逻辑运算符<br>！<a href="%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">2</a><br>用逻辑运算符连接而成表达式为逻辑表达式，逻辑表达式的值只有1或0。</p><p>！<a href="%E5%B8%B8%E8%A7%81%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E6%80%A7%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7">3</a><br>·&amp;&amp;若前为假，则不会再对其后方的程序计算。</p><h4 id="5-9补充内容"><a href="#5-9补充内容" class="headerlink" title="5.9补充内容"></a>5.9补充内容</h4><p>·白盒测试：又称为玻璃盒测试，也成为结构测试，尽量让测试数据覆盖程序中的每条语句，每个分支和每个判断与条件，且尽量减少重复覆盖。<br>·黑盒测试：只根据需求规格说明书的要求，检测程序的功能是否符合它的功能说明。<br>一般来说：选择有限数量的重要路径进行白盒测试，对重要的功能需求进行黑盒测试。<br>·边界测试：选用不合理的以及某些特殊的输入数据或者临界的点对程序进行测试，这称为边界测试。<br>·利用新引入的变量去除边界值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mark,score;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;score);</span><br><span class="line">mark=score&lt;<span class="number">0</span>||score&gt;<span class="number">100</span>?<span class="number">-1</span>:score/<span class="number">10</span>;<span class="comment">//score&lt;0作为无效字符输出，score&gt;100,则mark为-1同样也可以作为无效输出。</span></span><br><span class="line"><span class="keyword">switch</span> (mark)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对输入非法字符的检查和处理"><a href="#对输入非法字符的检查和处理" class="headerlink" title="对输入非法字符的检查和处理"></a>对输入非法字符的检查和处理</h5><p>(第六章后回来补充)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line">c=<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c);<span class="comment">//scanf的返回值即赋值的个数</span></span><br></pre></td></tr></table></figure><p>·采用fflush()函数</p><h5 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h5><p>！<a href="%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6.png">位运算符</a><br>·两数的位运算，先化为2进制数再进行运算</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;5-1算法的概念及其描述方法&quot;&gt;&lt;a href=&quot;#5-1算法的概念及其描述方法&quot; class=&quot;headerlink&quot; title=&quot;5.1算法的概念及其描述方法&quot;&gt;&lt;/a&gt;5.1算法的概念及其描述方法&lt;/h3&gt;&lt;h4 id=&quot;5-1-1算法的概念&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c-第4章-键盘输入和屏幕输出</title>
    <link href="http://example.com/2022/09/15/c-%E7%AC%AC4%E7%AB%A0-%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%92%8C%E5%B1%8F%E5%B9%95%E8%BE%93%E5%87%BA/"/>
    <id>http://example.com/2022/09/15/c-%E7%AC%AC4%E7%AB%A0-%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%92%8C%E5%B1%8F%E5%B9%95%E8%BE%93%E5%87%BA/</id>
    <published>2022-09-15T01:43:52.000Z</published>
    <updated>2022-09-16T03:09:35.257Z</updated>
    
    <content type="html"><![CDATA[<h3 id="4-1单个字符的输入-输出"><a href="#4-1单个字符的输入-输出" class="headerlink" title="4.1单个字符的输入/输出"></a>4.1单个字符的输入/输出</h3><h4 id="4-1-1字符常量"><a href="#4-1-1字符常量" class="headerlink" title="4.1.1字符常量"></a>4.1.1字符常量</h4><p>·常用的转义字符<br>！<a href="%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6.png">1</a><br>转义字符整体值占用一个字节</p><p>·字符型变量的取值取决于计算机系统所使用的字符集，目前最为广泛使用的是ASCII码.<br>字符型变量既可以用整型值输出，也可以用字符常量输出，每个字符都有一个等价的整型值与之相对应<br>·int型数据在16位中占2个字节，在32位系统中占4个字节；char型数据只占1个字节</p><h4 id="4-1-2-字符的输入-输出"><a href="#4-1-2-字符的输入-输出" class="headerlink" title="4.1.2 字符的输入\输出"></a>4.1.2 字符的输入\输出</h4><p>·通过getchar与putchar来实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line">ch=getchar();<span class="comment">//getchar(ch)为错误的使用方法</span></span><br><span class="line">putcha(ch);</span><br><span class="line"><span class="comment">//putchar(&#x27;\n&#x27;);转义字符也是用&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>putchar只能输出字符</p><h3 id="4-2数据的格式化屏幕输出"><a href="#4-2数据的格式化屏幕输出" class="headerlink" title="4.2数据的格式化屏幕输出"></a>4.2数据的格式化屏幕输出</h3><p>！<a href="%E5%87%BD%E6%95%B0printf%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%BD%AC%E5%8C%96%E8%AF%B4%E6%98%8E.png">2</a><br>·举例表示科学计数法： 2.1E5 = 2.1×105</p><p>·关于double和float类型的数据输出<br>正常以%f来输出，默认为6个小数位，若使用域宽和精度，如%7.2f表示域宽为7，精度为2，则输出数据所占的字符宽度为7，小数点后两位，如果输出的是33，则应该写成  33.00（小数点同样也算一个字符宽度）</p><p>·域宽对整数部分，不足没有影响，如：4.12用%2.2f输出仍然为4.12，但是4.121用%2.2f输出为4.12。域宽对整数部分只有多的影响（要留空格），没有域宽不够的问题。</p><p>·%-2d，%-3.1f是什么意思<br>即输出结果为左对齐。</p><h3 id="4-3数据的格式化键盘输入"><a href="#4-3数据的格式化键盘输入" class="headerlink" title="4.3数据的格式化键盘输入"></a>4.3数据的格式化键盘输入</h3><p>·与printf类似的是，scanf有域宽，但是没有精度，其精度为0<br>·在用scanf输入数值型数据时候，出现以下三种情况都认为数据输入结束<br>①遇到回车符、空格符、制表符（Tab）<br>②达到输入域宽<br>③遇非法字符输入</p><p>·多个数据输入时候，输入的格式应与scanf前半段保持一致才能准确输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a ,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);<span class="comment">//应输入a b</span></span><br><span class="line"><span class="comment">//若要求输入1234，且a=12，b=34，应为</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%2d%2d&quot;</span>,&amp;a,&amp;b);<span class="comment">//通过限制域宽</span></span><br><span class="line"><span class="comment">//如要使其不考虑分隔符，应输入为</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%*c%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="comment">//此时以空格符、回车符、逗号、制表符、-，都能正常读入</span></span><br></pre></td></tr></table></figure><p>·在使用scanf的时候不可以在””内加上\n，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br></pre></td></tr></table></figure><p>C程序执行scanf时，会从缓冲区读数据，如果缓冲区是空的，就阻塞住，等待你从键盘输入。<br>正常的scanf(“%d”,a);输入12\n，程序读到12，此时缓冲区剩下\n,缓冲区非空，程序正常运行。但是scanf(“%d\n”,a);输入12\n，程序读到12\n,缓冲区不留东西，程序无法继续运行，此时输入多个回车仍然没有效果，因为\n在缓冲区中对应的个数是无限的，需要在输入一次数据，让程序捕捉到有用的数据打断\n的这种连续。</p><h3 id="4-4扩展内容"><a href="#4-4扩展内容" class="headerlink" title="4.4扩展内容"></a>4.4扩展内容</h3><h4 id="4-4-1-用-c输入字符存在的问题"><a href="#4-4-1-用-c输入字符存在的问题" class="headerlink" title="4.4.1 用%c输入字符存在的问题"></a>4.4.1 用%c输入字符存在的问题</h4><p>·在用%c格式读入字符时，空格字符和转义字符（包括回车）都会被作为有效字符读入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c);</span><br><span class="line"><span class="comment">//此时的输出结果仅有c的数值,回车符被%c读入了</span></span><br></pre></td></tr></table></figure><p>解决方法有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"><span class="comment">//getchar();</span></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c);</span><br><span class="line"><span class="comment">//或是scanf(&quot; %c&quot;,&amp;c);增加一个空格</span></span><br></pre></td></tr></table></figure><h4 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h4><p>·如何输出’a’的形式<br>printf(“&#39;%c&#39;“);<br>putchar只能输出一个字符，无法输出该中形式。</p><p>·ASCLL值，为a-A=32;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;4-1单个字符的输入-输出&quot;&gt;&lt;a href=&quot;#4-1单个字符的输入-输出&quot; class=&quot;headerlink&quot; title=&quot;4.1单个字符的输入/输出&quot;&gt;&lt;/a&gt;4.1单个字符的输入/输出&lt;/h3&gt;&lt;h4 id=&quot;4-1-1字符常量&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c-第3章-基本算术计算</title>
    <link href="http://example.com/2022/09/14/c-%E7%AC%AC3%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%9C%AF%E8%AE%A1%E7%AE%97/"/>
    <id>http://example.com/2022/09/14/c-%E7%AC%AC3%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%9C%AF%E8%AE%A1%E7%AE%97/</id>
    <published>2022-09-14T07:52:08.000Z</published>
    <updated>2022-09-16T07:10:40.853Z</updated>
    
    <content type="html"><![CDATA[<h3 id="3-1-C运算符和表达式"><a href="#3-1-C运算符和表达式" class="headerlink" title="3.1 C运算符和表达式"></a>3.1 C运算符和表达式</h3><h4 id="3-1-1算术运算符和表达式"><a href="#3-1-1算术运算符和表达式" class="headerlink" title="3.1.1算术运算符和表达式"></a>3.1.1算术运算符和表达式</h4><p>·只需要一个操作数的运算符称为一元运算符（单目运算符），两个为二元运算符（双目运算符），三个为三元运算符（三目运算符）<br>·计算相反数是一元运算符，条件运算符是c里面唯一一个三元运算符，其余的为二元运算符<br>·在c中，求余运算限定参与运算的两个操作数必须为整型，不能对两个实型数据进行求余运算。求余运算中，余数与被除数的符号相同。</p><p>·在第三章中，优先级：取相反数&gt;乘除取余数&gt;加减运算</p><h4 id="关于复合赋值运算符"><a href="#关于复合赋值运算符" class="headerlink" title="关于复合赋值运算符"></a>关于复合赋值运算符</h4><p>涉及算术运算的复合赋值运算符有五个，分别为：<br>+=、-=、* =、/=、%=<br>a+=1→a=a+1<br>·需要注意的是，多次使用复合赋值运算符，a的大小会一直在改变</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">3</span>;</span><br><span class="line">a+=a-=a*a;</span><br><span class="line">a+=a-=a*=a;</span><br></pre></td></tr></table></figure><p>输出分别为-12和0</p><h4 id="3-1-3-增一和减一运算符"><a href="#3-1-3-增一和减一运算符" class="headerlink" title="3.1.3 增一和减一运算符"></a>3.1.3 增一和减一运算符</h4><p><img src="/2022/09/14/c-%E7%AC%AC3%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%9C%AF%E8%AE%A1%E7%AE%97/%E5%A2%9E%E4%B8%80%E5%87%8F%E4%B8%80%E8%BF%90%E7%AE%97.png" alt="2"><br>关于m、n，执行语句后n不变，m的值是n加减一前的或者是加减一后的<br>·增一减一运算符都是一元运算符</p><p>·在输出的时候由于++的位置不同输出结果也会有所差异</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n++)；</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,++n);</span><br></pre></td></tr></table></figure><p>前者输出的值是n，后者输出的值是n+1</p><p>·增一减一运算中，++与–的运算对象只能是n，不能是(-n)这个整体<br>同时n++只表示，运算对象是n，然后根据++的位置判断进行运算，其不参与到其他运算符的优先顺序的比较</p><h4 id="3-2宏常量和宏替换"><a href="#3-2宏常量和宏替换" class="headerlink" title="3.2宏常量和宏替换"></a>3.2宏常量和宏替换</h4><p>·在进行圆的面积和周长计算时，π在程序中是用一个近似相等的常数来表示的，这样的数被称为幻数，使用幻数在对精度进行修改的时候可能会有纰漏，固可以把幻数定义为<em>宏变量或者是const常量</em><br>在表头#define π 3.1415926<br>此即为用宏常量定义π</p><p>·宏常量也成为符号常量，其一般表示形式为<br>#define 表示串 字符串</p><h4 id="3-3const-常量"><a href="#3-3const-常量" class="headerlink" title="3.3const 常量"></a>3.3const 常量</h4><p>·与宏定义类似的使用方法，但加在 int main(){}里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> π=<span class="number">3.1415</span>;<span class="comment">//需要注明幻数的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4自动类型转换与强制类型转换运算符"><a href="#3-4自动类型转换与强制类型转换运算符" class="headerlink" title="3.4自动类型转换与强制类型转换运算符"></a>3.4自动类型转换与强制类型转换运算符</h4><p>！<a href="%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99">3</a><br>·类型转换一般由低专向高，由高转向低容易出现小数位、信息的丢失</p><p>·强制类型转换运算符使用例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m=<span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;m/2=%f&quot;</span>,(<span class="type">float</span>)m/<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>输出结果是2.5000，强制类型转换要对m使用，对整体无法改变m的数据类型，只能改变结果的数据类型</p><p>·如果需要输出的结果是小数，除了强制类型转换以外，还可以：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m=<span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,m*<span class="number">0.4</span>);</span><br><span class="line"><span class="comment">//或是:</span></span><br><span class="line"><span class="type">double</span> b=m*<span class="number">0.4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,b);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m=<span class="number">5</span>;</span><br><span class="line"><span class="type">double</span> s=<span class="number">0.4</span>*m;<span class="comment">//s的类型必须是double</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,s);</span><br></pre></td></tr></table></figure><h4 id="3-5-常用的标准数学函数"><a href="#3-5-常用的标准数学函数" class="headerlink" title="3.5 常用的标准数学函数"></a>3.5 常用的标准数学函数</h4><p>·关于数学公式有几个需要注意的地方<br>例如数学公式s=1/2(a+b+C)<br>在语法上容易写错成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="number">1</span>/<span class="number">2</span>*(a+b+c);<span class="comment">//结果为0</span></span><br><span class="line">s=(<span class="type">float</span>)((a+b+c)/<span class="number">2</span>);<span class="comment">//对整体进行强制类型转换</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;3-1-C运算符和表达式&quot;&gt;&lt;a href=&quot;#3-1-C运算符和表达式&quot; class=&quot;headerlink&quot; title=&quot;3.1 C运算符和表达式&quot;&gt;&lt;/a&gt;3.1 C运算符和表达式&lt;/h3&gt;&lt;h4 id=&quot;3-1-1算术运算符和表达式&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c-13章 文件操作基础</title>
    <link href="http://example.com/2022/05/01/c-13%E7%AB%A0-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/05/01/c-13%E7%AB%A0-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%9F%BA%E7%A1%80/</id>
    <published>2022-05-01T09:27:45.000Z</published>
    <updated>2022-05-01T14:21:42.921Z</updated>
    
    <content type="html"><![CDATA[<h3 id="13-1-全局变量：定义在函数之外的变量，全局的生存期和作用域"><a href="#13-1-全局变量：定义在函数之外的变量，全局的生存期和作用域" class="headerlink" title="13.1 全局变量：定义在函数之外的变量，全局的生存期和作用域"></a>13.1 全局变量：定义在函数之外的变量，全局的生存期和作用域</h3><p>·定义在函数外面的变量是全局变量<br>·全局变量具有全局的生存期和作用域<br>·它们与任何的函数都无关<br>·任何的函数内部都可以使用它们<br>·全局变量一般放在表头的位置</p><h4 id="全局变量初始化"><a href="#全局变量初始化" class="headerlink" title="全局变量初始化"></a>全局变量初始化</h4><p>·没有做初始化的全局变量会得到0值，指针得到NULL<br>·如何做初始化？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> gAll=<span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> g2=gAll;<span class="comment">//这是不行的，除非gAll加上const，即：</span></span><br><span class="line"><span class="comment">//const int gAll=12；才行</span></span><br></pre></td></tr></table></figure><p>·若在函数里头有同名的变量，全局变量会被隐藏</p><h3 id="13-2静态本地变量：能在函数结束后继续保有原值的本地变量"><a href="#13-2静态本地变量：能在函数结束后继续保有原值的本地变量" class="headerlink" title="13.2静态本地变量：能在函数结束后继续保有原值的本地变量"></a>13.2静态本地变量：能在函数结束后继续保有原值的本地变量</h3><p>·在本地变量前面加上static修饰符会变成静态本地变量<br>·与普通的本地变量不同的是静态本地变量离开后不会被重新初始化<br>·静态本地变量具有全局的生存区，函数内的局部作用域<br>·static在这里的意思是局部作用域(本地可以访问)</p><h3 id="13-3返回指针的函数，使用全局变量的贴士"><a href="#13-3返回指针的函数，使用全局变量的贴士" class="headerlink" title="13.3返回指针的函数，使用全局变量的贴士"></a>13.3返回指针的函数，使用全局变量的贴士</h3><h4 id="返回指针的函数"><a href="#返回指针的函数" class="headerlink" title="返回指针的函数"></a>返回指针的函数</h4><p>·函数返回指针是不安全的（返回一个本地变量的地址是不安全的，可能返回的地址会被分配给另一个函数去使用）<br>·返回全局变量和静态本地变量的地址是安全的<br>·不要使用全局变量在函数间传递参数和结果，尽量少使用全局变量</p><h3 id="13-4-宏定义"><a href="#13-4-宏定义" class="headerlink" title="13.4 宏定义"></a>13.4 宏定义</h3><h4 id="编译预处理指令"><a href="#编译预处理指令" class="headerlink" title="编译预处理指令"></a>编译预处理指令</h4><p>·#开头的是编译预处理指令<br>·#define用来定义一个宏 eg：#define pi 3//作用类似于pi=3，是把正文中的pi用3来代替</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> p1 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> p2 p1*2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRT printf(<span class="string">&quot;%f&quot;</span>,p1);\  <span class="comment">//这里是接下去的意思</span></span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,p2) </span><br></pre></td></tr></table></figure><p>·#define_DEBUG—&gt;没有值的宏<br>·编程里面有一些预定的宏，eg_file_和_LINE_</p><h3 id="13-5-带参数的宏"><a href="#13-5-带参数的宏" class="headerlink" title="13.5 带参数的宏"></a>13.5 带参数的宏</h3><h4 id="像函数的宏"><a href="#像函数的宏" class="headerlink" title="像函数的宏"></a>像函数的宏</h4><p>·#define cube(x) ((x)* (x)* (x))<br>·宏可以带参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> cube(x) ((x)* (x)* (x))</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,cube(<span class="number">5</span>));<span class="comment">//类似函数读入5输出((x)* (x)* (x))的结果</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·定义带参数的宏的原则<br>·一切都必须要有括号：最后整个宏的值也要有括号<br>·参数出现的所有地方都必须要有括号</p><p>·宏的结尾一定不能有；</p><h3 id="13-6-大程序"><a href="#13-6-大程序" class="headerlink" title="13.6 大程序"></a>13.6 大程序</h3><p>·新建一个项目，把几个源代码文件加入进去，编译器在编译的时候会把一个项目中所有的源代码文件都编译后再链接起来</p><h3 id="13-7-头文件"><a href="#13-7-头文件" class="headerlink" title="13.7 头文件"></a>13.7 头文件</h3><p>·把函数的原型放到一个头文件中（以.h结尾）中，在需要调用这个函数的源代码文件（.c文件）中#include这个头文件，就能让编译器在编译的时候知道函数的原型。如变量的类型（#include”max.h”)<br>·.c文件里的函数是完整的，但是.h文件的里的函数就和直接定义在int main之前的函数一样可以只写函数名和函数变量。<br>·关于头文件被引用进来,有两种写法：<br>①””要求编译器首先在当前目录（即.c文件所在的目录）来寻找这个文件，如果没有，到编译器指定的目录去寻找<br>②&lt;&gt;让编译器只在指定的目录去找<br>·一般任何的.c都有对应的同名的.h文件，把所有对外公开的函数的原型和全局变量的声明放入</p><h3 id="13-8-声明"><a href="#13-8-声明" class="headerlink" title="13.8 声明"></a>13.8 声明</h3><p>·extern int i;是变量的声明，放在.h文件中可以发挥作用<br>·标准头文件结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _list_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _list_h_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可以避免重复定义、重复include</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;13-1-全局变量：定义在函数之外的变量，全局的生存期和作用域&quot;&gt;&lt;a href=&quot;#13-1-全局变量：定义在函数之外的变量，全局的生存期和作用域&quot; class=&quot;headerlink&quot; title=&quot;13.1 全局变量：定义在函数之外的变量，全局的生存期和作用</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c-第12章 结构体和数据结构基础</title>
    <link href="http://example.com/2022/04/29/c-%E7%AC%AC12%E7%AB%A0-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/04/29/c-%E7%AC%AC12%E7%AB%A0-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/</id>
    <published>2022-04-29T13:30:38.000Z</published>
    <updated>2022-05-02T14:59:15.734Z</updated>
    
    <content type="html"><![CDATA[<h3 id="12-1-枚举"><a href="#12-1-枚举" class="headerlink" title="12.1 枚举"></a>12.1 枚举</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> 枚举类型的名字 &#123;</span>名字a，……，名字b&#125;；</span><br><span class="line"><span class="comment">//eg:</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">COLOR</span> &#123;</span>red,greem,yellow&#125;;</span><br></pre></td></tr></table></figure><p>·它们作为int类型的常量，值依次从0到n<br>·当需要一些可以排列起来的常量值的时，定义枚举的意义就是给这些常量值名字。<br>·枚举的这些量要放在int main的前面</p><p>·枚举可以用来计算值的数量，省去一次遍历；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">COLOR</span> &#123;</span>red,green,yellow,NumCOLORS&#125;;</span><br></pre></td></tr></table></figure><p>·声明枚举量的时候可以指定值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">COLOR</span> &#123;</span>red=<span class="number">4</span>,green,yellow=<span class="number">8</span>&#125;;\\green是<span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="12-2结构类型"><a href="#12-2结构类型" class="headerlink" title="12.2结构类型"></a>12.2结构类型</h3><h4 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h4><p>·声明结构的形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>&#123;</span></span><br><span class="line"><span class="type">int</span> month;</span><br><span class="line"><span class="type">int</span> day;</span><br><span class="line"><span class="type">int</span> year;</span><br><span class="line">&#125;;<span class="comment">//注意这里要加上分号,没有分号的话定义的变量类型无法拿出来使用</span></span><br></pre></td></tr></table></figure><p>·在使用结构的时候：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构名 变量名 </span></span><br><span class="line"><span class="class"><span class="title">eg</span>:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">today</span>;</span></span><br></pre></td></tr></table></figure><p>在这之后可以使用today里的三个变量。<br>·另两种种形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125; p1,p2; <span class="comment">//p1和p2都是无名结构，里面都有xy</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125; p1,p2;<span class="comment">//p1和p2 都是point里面有x和y的值t</span></span><br></pre></td></tr></table></figure><h4 id="结构的初始化"><a href="#结构的初始化" class="headerlink" title="结构的初始化"></a>结构的初始化</h4><p>·两种方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">today</span> &#123;</span><span class="number">07</span>,<span class="number">31</span>,<span class="number">2014</span>&#125;;<span class="comment">//类似数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">this</span> <span class="title">month</span>&#123;</span>.month=<span class="number">7</span>,.year=<span class="number">2014</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="结构成员和数组元素的区别"><a href="#结构成员和数组元素的区别" class="headerlink" title="结构成员和数组元素的区别"></a>结构成员和数组元素的区别</h4><p>·结构成员的类型可以不一样，但是数组元素的类型都一样<br>·数组用[]运算符和下标访问成员，结构用.运算符和名字访问来访问成员<br>eg：today.day  p1.x;</p><h4 id="结构运算"><a href="#结构运算" class="headerlink" title="结构运算"></a>结构运算</h4><p>·要访问整个结构，直接用结构变量的名字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于一个已经初始化的结构来说</span></span><br><span class="line">p1=(<span class="keyword">struct</span> point)&#123;<span class="number">2</span>,<span class="number">565</span>&#125;<span class="comment">//相当于再次赋值，（）表示强制转换类型</span></span><br><span class="line">p1=p2;<span class="comment">//p2对p1内的结构成员进行赋值</span></span><br></pre></td></tr></table></figure><p>数组无法做此类运算</p><h4 id="结构指针"><a href="#结构指针" class="headerlink" title="结构指针"></a>结构指针</h4><p>·和数组不同，结构变量的名字并不是结构变量的地址，必须用&amp;运算符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> *<span class="title">p</span>=</span>&amp;today;</span><br></pre></td></tr></table></figure><h3 id="12-3-结构与函数"><a href="#12-3-结构与函数" class="headerlink" title="12.3 结构与函数"></a>12.3 结构与函数</h3><h4 id="结构作为函数参数"><a href="#结构作为函数参数" class="headerlink" title="结构作为函数参数"></a>结构作为函数参数</h4><p>·整个结构可以作为参数的值传入函数<br>·这个时候相当于是在函数内新建一个结构变量并且复制所调用结构的值<br>·也可以返回一个结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> the 函数名（<span class="class"><span class="keyword">struct</span> 结构名 <span class="title">d</span>）；</span></span><br><span class="line"><span class="class">函数名（变量名）；</span></span><br><span class="line"><span class="class"><span class="title">eg</span>：</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">the</span> <span class="title">numberOFDays</span>(<span class="keyword">struct</span> <span class="title">date</span> <span class="title">d</span>);</span></span><br><span class="line">numberOFDays (today);\\可以单一<span class="keyword">return</span>出某个变量</span><br></pre></td></tr></table></figure><h4 id="输入结构"><a href="#输入结构" class="headerlink" title="输入结构"></a>输入结构</h4><p>·没有直接的方式可以一次scanf一个结构<br>·但可以构造一个函数，在函数内构造一个新的结构把赋值完成的结构传给旧的这个结构</p><p>·这时可以用一个指向结构的指针来解决</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>&#123;</span></span><br><span class="line"><span class="type">int</span> day;</span><br><span class="line"><span class="type">int</span> month;</span><br><span class="line"><span class="type">int</span> year;</span><br><span class="line">&#125; myday;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>*<span class="title">p</span>=</span>&amp;myday;</span><br><span class="line"><span class="comment">//那么如何用指针来表示结构变量中的成员呢？</span></span><br><span class="line"><span class="comment">//(*p).month=12;p.month也是指针</span></span><br><span class="line">p-&gt;month=<span class="number">12</span>;</span><br></pre></td></tr></table></figure><p>·结构指针如何传入函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>&#123;</span></span><br><span class="line"><span class="type">int</span> day;</span><br><span class="line"><span class="type">int</span> month;</span><br><span class="line"><span class="type">int</span> year;</span><br><span class="line">&#125; myday;</span><br><span class="line">getmyday(&amp;myday);<span class="comment">//直接取地址符不用再用一个指针来指向它</span></span><br><span class="line"><span class="comment">//在表头的getmyday是这样的：</span></span><br><span class="line">getmyday(<span class="keyword">struct</span> date *p);</span><br></pre></td></tr></table></figure><h3 id="12-4-结构中的结构"><a href="#12-4-结构中的结构" class="headerlink" title="12.4 结构中的结构"></a>12.4 结构中的结构</h3><h4 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">time</span>&#123;</span></span><br><span class="line"><span class="type">int</span> hour;</span><br><span class="line"><span class="type">int</span> minute;</span><br><span class="line"><span class="type">int</span> second;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">time</span> <span class="title">testtime</span>[3]=</span>&#123;</span><br><span class="line">&#123;<span class="number">11</span>,<span class="number">33</span>,<span class="number">53</span>&#125;,&#123;<span class="number">11</span>,<span class="number">33</span>,<span class="number">44</span>&#125;,&#123;<span class="number">3</span>,<span class="number">45</span>,<span class="number">56</span>&#125;</span><br><span class="line">&#125;;<span class="comment">//之后可以把testtime[1]单独拿出来使用</span></span><br></pre></td></tr></table></figure><h4 id="嵌套结构"><a href="#嵌套结构" class="headerlink" title="嵌套结构"></a>嵌套结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">pt1</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">pt2</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这时候rectangle就是一个嵌套结构</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> <span class="title">r</span>,*<span class="title">rp</span>//定义了<span class="title">r</span>和<span class="title">r</span>的指针</span></span><br><span class="line"><span class="class"><span class="title">rp</span>=</span>&amp;r;</span><br></pre></td></tr></table></figure><p>·这里就可以有r.pt1.x、rp-&gt;pt1.x,但是没有rp-&gt;pt1-&gt;x(因为pt1不是指针)<br>·如果是结构中结构的数组则是这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">pt1</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">pt2</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> <span class="title">pp</span>[2]=</span>&#123;</span><br><span class="line">&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;&#125;,</span><br><span class="line">&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="12-5-类型定义"><a href="#12-5-类型定义" class="headerlink" title="12.5 类型定义"></a>12.5 类型定义</h3><p>类型定义的初衷是为了让我们不用写struct（雾）</p><h4 id="自定义数据类型（typedef）"><a href="#自定义数据类型（typedef）" class="headerlink" title="自定义数据类型（typedef）"></a>自定义数据类型（typedef）</h4><p>·typedef int Length<br>使得Length成为int类型的别名，Length可以代替int出现<br>同样的可以用在int身上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125; num;<span class="comment">//这里的num不是定义一个新的point结构，而是把struct point的作用附加到num身上</span></span><br><span class="line">num d=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;；<span class="comment">//此时d是被定义的一个新的结构</span></span><br></pre></td></tr></table></figure><h3 id="12-6联合"><a href="#12-6联合" class="headerlink" title="12.6联合"></a>12.6联合</h3><p>·union在写法上与struct基本一致</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">AnElt</span>&#123;</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line">&#125;elt <span class="number">1</span>,elt <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>·这里是大家联合使用同一个空间，同一时间下只有一个成员是有效的<br>·union的大小是最大的成员<br>·初始化时对第一个成员进行初始化<br>·union主要用在以下的一个情景：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">char</span> ch[<span class="keyword">sizeof</span>(<span class="type">int</span>)];</span><br><span class="line">&#125; CHI;</span><br></pre></td></tr></table></figure><p>·用途：比如要把一个整数写到二进制里头union可以作为媒介。</p><h3 id="12-7-格式化输入输出"><a href="#12-7-格式化输入输出" class="headerlink" title="12.7 格式化输入输出"></a>12.7 格式化输入输出</h3><h4 id="对于printf"><a href="#对于printf" class="headerlink" title="对于printf"></a>对于printf</h4><p>%[flags][width][.prec][hiL]type</p><p>[flag]<br>·-：表示左对齐 eg:%9d意味着有占9个字节，如果填不满的话是默认右对齐的，-可以使其左对齐<br>·+：在前面放+或者-，相当于强制输出+号。<br>·：（space）正数留空<br>·0：0填充：会在数字的左边没有留空的地方留下0来占据空位</p><p>[width][.prec]<br>·number：最小字符数（占据的总的字符空间）<br>· * ：下一个参数是字符数（同第一点作用一样相当于用* 来代替一和三点），放到，后面<br>· .number ：小数点后的位数（小数点后的字符空间）<br>· .* 下一个参数是小数点后的位数</p><p>[hlL]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hh 单个字节</span><br><span class="line">h  short</span><br><span class="line">l  long</span><br><span class="line">l long long</span><br><span class="line">L  long double</span><br></pre></td></tr></table></figure><p>type<br><img src="/2022/04/29/c-%E7%AC%AC12%E7%AB%A0-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/1.JPG" alt="233"></p><p>·%n的使用方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d%n&quot;</span>,<span class="number">12346</span>,&amp;num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);<span class="comment">//%n用来接在后面表示输出了n个字节</span></span><br></pre></td></tr></table></figure><h4 id="对于scanf"><a href="#对于scanf" class="headerlink" title="对于scanf"></a>对于scanf</h4><p><img src="/2022/04/29/c-%E7%AC%AC12%E7%AB%A0-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/2.JPG" alt="236"><br>· * 表示跳过，输入了两个数字23 45 ，只接受到23</p><p><img src="/2022/04/29/c-%E7%AC%AC12%E7%AB%A0-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/3.JPG" alt="235"></p><h3 id="12-8-文件输入输出"><a href="#12-8-文件输入输出" class="headerlink" title="12.8 文件输入输出"></a>12.8 文件输入输出</h3><p>·用&gt;和&lt;重定向<br>·&gt;是输入到后面的文件，&lt;是读取后面的文件</p><h3 id="12-9-可变数组"><a href="#12-9-可变数组" class="headerlink" title="12.9 可变数组"></a>12.9 可变数组</h3><p>·可变数组的函数库</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先定义一个结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> *<span class="built_in">array</span>;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line">&#125; Array;</span><br><span class="line">Array a；</span><br><span class="line">Array <span class="title function_">array_creat</span><span class="params">(<span class="type">int</span> init_size)</span>;</span><br><span class="line"><span class="comment">//Array a=array_creat(100);分配空间，具有100个int</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_free</span><span class="params">(Array *a)</span>;<span class="comment">//Array *a表示传入的是指针</span></span><br><span class="line"><span class="comment">//array_free(&amp;a);把a的array给free掉</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_size</span><span class="params">(<span class="type">const</span> Array *a)</span>;</span><br><span class="line"><span class="comment">// array_size[&amp;a];相当于a.size，（封装）</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">array_at</span><span class="params">(Array *a, <span class="type">int</span> index)</span>;</span><br><span class="line"><span class="comment">// array_at(&amp;a,0)返回的是a里面的array数组的第1个的指针，相当于a</span></span><br><span class="line"><span class="comment">// 所以我们可以对数组的第n+1个元素进行赋值，</span></span><br><span class="line"><span class="comment">// *array_at(&amp;a,0)=3;</span></span><br><span class="line"><span class="comment">// 在定义完之后，index会比size小1，因为数组从0开始</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_inflate</span><span class="params">(Array *a,<span class="type">int</span> more_size)</span>;</span><br><span class="line"><span class="comment">//  array_inflate(p,需要空间的数量);</span></span><br></pre></td></tr></table></figure><p>但是在这里的array_inflate是拷贝生成一个更大的数组，一来耗时间，二来难免遇到内存空间不够的情况，所以这里就是需要链表发挥作用的地方。</p><h3 id="12-10-链表"><a href="#12-10-链表" class="headerlink" title="12.10 链表"></a>12.10 链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _NODE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NODE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span>&#123;</span></span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;12-1-枚举&quot;&gt;&lt;a href=&quot;#12-1-枚举&quot; class=&quot;headerlink&quot; title=&quot;12.1 枚举&quot;&gt;&lt;/a&gt;12.1 枚举&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>”c-字符串数组及函数“</title>
    <link href="http://example.com/2022/04/29/%E2%80%9Dc-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%8F%8A%E5%87%BD%E6%95%B0%E2%80%9C/"/>
    <id>http://example.com/2022/04/29/%E2%80%9Dc-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%8F%8A%E5%87%BD%E6%95%B0%E2%80%9C/</id>
    <published>2022-04-29T07:51:28.000Z</published>
    <updated>2022-05-01T12:28:22.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串数组及函数"><a href="#字符串数组及函数" class="headerlink" title="字符串数组及函数"></a>字符串数组及函数</h2><h3 id="1-1-字符串数组"><a href="#1-1-字符串数组" class="headerlink" title="1.1 字符串数组"></a>1.1 字符串数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>**a;</span><br></pre></td></tr></table></figure><p>a是一个指针，指向另一个指针，那个指针指向另一个字符（串）</p><h4 id="char-a-与char-a的区别"><a href="#char-a-与char-a的区别" class="headerlink" title="char a[][]与char* a的区别"></a>char a[][]与char* a的区别</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[][<span class="number">10</span>]; <span class="comment">//意思是有n个字符串，每个字符串的所占的空间不超过10。</span></span><br><span class="line"><span class="type">char</span> *a <span class="comment">//意思是有n个指针，没个对应一个字符串。</span></span><br></pre></td></tr></table></figure><h3 id="1-2-程序参数"><a href="#1-2-程序参数" class="headerlink" title="1.2 程序参数"></a>1.2 程序参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> <span class="type">const</span>*argv[])</span></span><br></pre></td></tr></table></figure><h4 id="1-3-1-putchar函数"><a href="#1-3-1-putchar函数" class="headerlink" title="1.3.1 putchar函数"></a>1.3.1 putchar函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="built_in">putchar</span>(c);</span><br></pre></td></tr></table></figure><p>·向标准输出写一个字符<br>·返回写了几个字符，EOF（-1）表示失败<br>（作用有些类似于printf）<br>·putchar对指针输出的是原原本本的（指针所对的某个位置），但是对于printf来说，输出指向字符串数组的指针的数组名，输出的会是第一个字符串（无论是一维还是二维）</p><h4 id="1-3-1-getchar函数"><a href="#1-3-1-getchar函数" class="headerlink" title="1.3.1 getchar函数"></a>1.3.1 getchar函数</h4><p>·从标准输入读一个字符<br>·返回类型是int是为了返回EOF(-1)<br>（作用有些类似于scanf）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c;</span><br><span class="line">c=getchar()</span><br></pre></td></tr></table></figure><p>个人认为：之所以要用getchar和putchar来输入输出字符，是因为scanf和printf的%c和%s使用较为麻烦</p><h3 id="1-4-字符串函数"><a href="#1-4-字符串函数" class="headerlink" title="1.4 字符串函数"></a>1.4 字符串函数</h3><p>字符串函数需要：include&lt;string.h&gt;</p><h4 id="1-4-1-strlen函数"><a href="#1-4-1-strlen函数" class="headerlink" title="1.4.1 strlen函数"></a>1.4.1 strlen函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">strlen</span>(a);</span><br></pre></td></tr></table></figure><h4 id="1-4-2-strcmp函数"><a href="#1-4-2-strcmp函数" class="headerlink" title="1.4.2 strcmp函数"></a>1.4.2 strcmp函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> b[] = <span class="string">&quot;adc&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">strcmp</span>(a, b));</span><br></pre></td></tr></table></figure><p>进行比较，&lt;=&gt;分别输出-1，0,1</p><h4 id="1-4-3-strcpy函数"><a href="#1-4-3-strcpy函数" class="headerlink" title="1.4.3 strcpy函数"></a>1.4.3 strcpy函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(dst,src);</span><br></pre></td></tr></table></figure><p>把src的值放到dst里，原函数里定义两个变量有restrict，表明二者不重叠（c99），这就是说，如果hello字符在1-5里面，想把它移到2-6，那是做不到的<br>我们可以利用strcpy函数来复制一个字符串，只能在数组内进行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> dst[]=<span class="string">&quot;0&quot;</span>;<span class="comment">//要先对其进行初始化</span></span><br><span class="line"><span class="type">char</span> src[<span class="number">6</span>]=&#123;<span class="string">&quot;Hello&quot;</span>&#125;</span><br><span class="line"><span class="type">char</span> dst=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(dst)+<span class="number">1</span>);<span class="comment">//</span></span><br><span class="line"><span class="built_in">strcpy</span>(dst,src);</span><br></pre></td></tr></table></figure><h4 id="1-4-4-strcat函数"><a href="#1-4-4-strcat函数" class="headerlink" title="1.4.4 strcat函数"></a>1.4.4 strcat函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(s1,s2);</span><br></pre></td></tr></table></figure><p>·把s2拷到s1后面，连接形成一个长的字符串<br>·返回s1<br>·s1必须要有足够的空间</p><ul><li>关于strcpy和strcat两个都存在安全问题，它们都有安全的版本</li></ul><h4 id="1-4-5-strchr和strrchr函数（从左和从右开始）"><a href="#1-4-5-strchr和strrchr函数（从左和从右开始）" class="headerlink" title="1.4.5 strchr和strrchr函数（从左和从右开始）"></a>1.4.5 strchr和strrchr函数（从左和从右开始）</h4><p>如果返回值是NULL表示没有找到<br>举例运用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>*p=<span class="built_in">strchr</span>(a,<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p);\\输出结果为llo，指针指向字符串数组的第一个地址输出会把整个字符串都输出。如果需要输出的是第二个l只需要输出p+<span class="number">1</span>即可。</span><br><span class="line"><span class="type">char</span>*t=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(p)+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(t,p)\\把p以后的东西拷贝的方法</span><br><span class="line"><span class="built_in">free</span>(t);</span><br></pre></td></tr></table></figure><p>那如何输出找出llo后前面的he呢</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>* p = <span class="built_in">strchr</span>(s, <span class="string">&#x27;l&#x27;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p);</span><br><span class="line"><span class="type">char</span> c = *p;</span><br><span class="line">*p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="type">char</span>* t = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s) + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(t, s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, t);</span><br><span class="line"><span class="built_in">free</span>(t);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字符串数组及函数&quot;&gt;&lt;a href=&quot;#字符串数组及函数&quot; class=&quot;headerlink&quot; title=&quot;字符串数组及函数&quot;&gt;&lt;/a&gt;字符串数组及函数&lt;/h2&gt;&lt;h3 id=&quot;1-1-字符串数组&quot;&gt;&lt;a href=&quot;#1-1-字符串数组&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>”第11章 指针和数组“</title>
    <link href="http://example.com/2022/04/25/%E2%80%9D%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E2%80%9C/"/>
    <id>http://example.com/2022/04/25/%E2%80%9D%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E2%80%9C/</id>
    <published>2022-04-25T07:48:10.000Z</published>
    <updated>2022-05-01T12:28:21.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h1><h3 id="11-1指针和一维数组的关系"><a href="#11-1指针和一维数组的关系" class="headerlink" title="11.1指针和一维数组的关系"></a>11.1指针和一维数组的关系</h3><p>定义一个数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>它的函数名a所表示的就是a[0]的地址，</p><h4 id="指针指向字符串，无法修改，需要引入“字符串-数组”来进行修改；-数组名代表的指针无法进行修改，需要指针指向数组，才能对其进行修改（-a和-p所起的作用是一样的，但是-a无法修改，-p可以修改）"><a href="#指针指向字符串，无法修改，需要引入“字符串-数组”来进行修改；-数组名代表的指针无法进行修改，需要指针指向数组，才能对其进行修改（-a和-p所起的作用是一样的，但是-a无法修改，-p可以修改）" class="headerlink" title="指针指向字符串，无法修改，需要引入“字符串=数组”来进行修改； 数组名代表的指针无法进行修改，需要指针指向数组，才能对其进行修改（* a和* p所起的作用是一样的，但是* a无法修改，* p可以修改）"></a>指针指向字符串，无法修改，需要引入“字符串=数组”来进行修改； 数组名代表的指针无法进行修改，需要指针指向数组，才能对其进行修改（* a和* p所起的作用是一样的，但是* a无法修改，* p可以修改）</h4><p>所以有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a+1==&amp;a[1];</span><br><span class="line">*(a+1)==a[1];</span><br></pre></td></tr></table></figure><h4 id="p-和p-1的区别；"><a href="#p-和p-1的区别；" class="headerlink" title="p++和p+1的区别；"></a>p++和p+1的区别；</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=a;</span><br><span class="line">p++;<span class="comment">//在原来的地址上直接加siezof（int），对其赋值；</span></span><br><span class="line">p+<span class="number">1</span>；<span class="comment">//先让右边的p指向下一个元素，然后让左边的p的地址等于下一个元素的地址；</span></span><br></pre></td></tr></table></figure><p>用两个函数说明:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  <span class="type">int</span> *p = &amp;(arr[<span class="number">2</span>]);</span><br><span class="line">  <span class="keyword">for</span> (; p &gt;= &amp;arr[<span class="number">2</span>]; p--)</span><br><span class="line">  &#123;</span><br><span class="line">    *(p++) = *p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">f2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  <span class="type">int</span> *p = &amp;(arr[<span class="number">2</span>]);</span><br><span class="line">  <span class="keyword">for</span> (; p &gt;= &amp;arr[<span class="number">2</span>]; p--)</span><br><span class="line">  &#123;</span><br><span class="line">    *(p+<span class="number">1</span>) = *p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>f1因为p在自己的地址上加一减一，陷入死循环，f2也在自己的地址上加一，但没有赋值，所以能离开循环。<br>p++同p+=1，p本身因为赋值指向的变量发生改变，而p+1只是整体暂时地指向了某个变量。<br>所以对于数组而言，需要暂时借用下一个元素的值而不改变指针的指向，+1作为整体即可。</p><h4 id="指针p指向数组b，是不需要-amp-符号的"><a href="#指针p指向数组b，是不需要-amp-符号的" class="headerlink" title="指针p指向数组b，是不需要&amp;符号的"></a>指针p指向数组b，是不需要&amp;符号的</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">12</span>,<span class="number">44</span>&#125;;</span><br><span class="line"><span class="type">int</span>*p=a;</span><br></pre></td></tr></table></figure><h3 id="指针和二维数组的关系"><a href="#指针和二维数组的关系" class="headerlink" title="指针和二维数组的关系"></a>指针和二维数组的关系</h3><h4 id="二维数组行地址和列地址的关系"><a href="#二维数组行地址和列地址的关系" class="headerlink" title="二维数组行地址和列地址的关系"></a>二维数组行地址和列地址的关系</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于一维数组</span></span><br><span class="line"><span class="type">char</span> A[]=&#123; &#125;;</span><br><span class="line"><span class="comment">//A表示的是A[0]的变量地址；而A+1可以表示A[0]的变量地址</span></span><br><span class="line"><span class="comment">//那么定义一个二维数组，有：</span></span><br><span class="line"><span class="type">char</span> a[i][j]=&#123;  &#125;;</span><br><span class="line"><span class="comment">//结论：a表示的是a[0]的变量地址；而a+1表示的是a[0][1]的变量地址，</span></span><br></pre></td></tr></table></figure><p>这里的”1”表示的是增加<br>1* sizeof（int），所以对于一维数组来说是要指向下一个元素的地址。<br>我们用字符来进行理解：假定二维数组第一个元素是”Hello”,那么整个a[0]都在里面<br>因为第二个下标决定字符串的长度，所以二维数组每一行都有j* sizeof（int），那么增加一个sizeof（int）<br>只能从a[0][0]→a[0][1]<br>所以有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i][j]=*(a[i]+j)=*(*(a+i)+j)=(*(a+i))[j];</span><br></pre></td></tr></table></figure><p>（简单记忆：一维数组，元素加一减一只有a能够发生指向性的改变，其它元素的地址只能由a加减来得到；二维数组，元素的加一减一只能由a和a[0]发生指向性的改变，a的加减改变只改变a的一维下标值，而a[0]的加减改变a的二维下标值，不管是一维数组还是二维数组，加减之后得到的整体仍是指针变量,所以我们不考虑它们非指针输出的其它结果，在二维数组里面，a+i,也不考虑结果（但是我们考虑* 后的结果））<br>所以要把整个数组的元素输出，应用一次或两次for循环。<br>a[0]的作用可以延伸到a[i]，故：a与a[i]都是指针变量；</p><h4 id="通过二维数组的行指针和列指针来引号二维数组元素"><a href="#通过二维数组的行指针和列指针来引号二维数组元素" class="headerlink" title="通过二维数组的行指针和列指针来引号二维数组元素"></a>通过二维数组的行指针和列指针来引号二维数组元素</h4><p>因为二维数组里，行指针定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">3</span>][<span class="number">9</span>] = &#123;<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>&#125;;<span class="comment">//这里用字符串数组举例</span></span><br><span class="line"><span class="type">char</span> *p=a;</span><br></pre></td></tr></table></figure><ul><li>p和* a只能表示某个字符串或者是某串数字；<br>所以需要引入列指针来精确地表示某个元素<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">3</span>][<span class="number">9</span>] = &#123;<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>&#125;;</span><br><span class="line"><span class="type">char</span> *p=a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>对于列指针，要从a[0][0]指向某个元素a[m][n],默认数组定义为a[i][j]<br>在将其视为一维数组的情况下，需要跳过”i* n+j”个元素<br>（能够当做一维数组运算的也就说明了为什么在定义二维数组的列指针的时候无须指定它的列数）<em>列指针+n把所有的字符串都放在同一行。</em><br>但是在定义二维数组的时候则相反，若没有定义列数，行指针无法加1<br> <em>行指针+n把字符按行列分列</em></li></ul><p>以下数据可用于验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int a[3][3] = &#123; &#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125; &#125;;</span></span><br><span class="line"><span class="comment">//char a[3][9] = &#123;&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;&#125;;</span></span><br><span class="line"><span class="comment">//char a[10] = &quot;hello&quot;;</span></span><br><span class="line"><span class="comment">//int a[10]=&#123;1,2,3,4,5&#125;;</span></span><br><span class="line"><span class="comment">//char a[5] = &quot;hello&quot;;</span></span><br><span class="line"><span class="comment">//a[i]=*(a+i)</span></span><br><span class="line"><span class="comment">//printf(&quot;%c&quot;,*a);</span></span><br><span class="line"><span class="comment">//printf(&quot;%s\n&quot;, *(a+1));</span></span><br><span class="line"><span class="comment">//printf(&quot;%p\n&quot;, &amp;a);</span></span><br></pre></td></tr></table></figure><h6 id="对于字符串数组（不论是一维还是二维），让指针指向数组名（即第一个地址）会将第一个字符串全部输出"><a href="#对于字符串数组（不论是一维还是二维），让指针指向数组名（即第一个地址）会将第一个字符串全部输出" class="headerlink" title="对于字符串数组（不论是一维还是二维），让指针指向数组名（即第一个地址）会将第一个字符串全部输出"></a>对于字符串数组（不论是一维还是二维），让指针指向数组名（即第一个地址）会将第一个字符串全部输出</h6><h4 id="11-2-动态内存分配"><a href="#11-2-动态内存分配" class="headerlink" title="11.2 动态内存分配"></a>11.2 动态内存分配</h4><p>对于c89来说，定义一个二维数组无法在定义的时候在[]内输入变量来定义数组的大小，这个时候就需要用到动态内存分配了。<br>动态内存分配是为某个指针分配一段连续的的空间，但对于指针来说，指向不变<br>注意：使用时需要：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include&lt;stdlib.h&gt;</span><br></pre></td></tr></table></figure><h5 id="11-2-1-malloc-函数"><a href="#11-2-1-malloc-函数" class="headerlink" title="11.2.1 malloc 函数"></a>11.2.1 malloc 函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>*p=<span class="literal">NULL</span>;</span><br><span class="line">p=(<span class="type">int</span>*)<span class="built_in">malloc</span>(len*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>这里的意识是定义一个指针，然后利用sizeof函数，计算得到一个int函数的大小，再进行动态分配，也就是说函数malloc的返回值的void* 类型转换成了int* 类型，申请了一个int大小的字节数赋值给指针p<br>注意：如果是对字符串进行申请，后面的长度需要+1；</p><h5 id="11-2-2-calloc函数"><a href="#11-2-2-calloc函数" class="headerlink" title="11.2.2 calloc函数"></a>11.2.2 calloc函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>*p=<span class="literal">NULL</span>;</span><br><span class="line">p=(<span class="type">float</span>*)<span class="built_in">calloc</span>(len,sizof(<span class="type">int</span>));<span class="comment">//与前者的区别仅在*与，之间；</span></span><br></pre></td></tr></table></figure><h5 id="11-2-3-free函数"><a href="#11-2-3-free函数" class="headerlink" title="11.2.3 free函数"></a>11.2.3 free函数</h5><p>在使用动态内存分配之后需要释放所申请过的储存空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(a); <span class="comment">//以释放内存</span></span><br></pre></td></tr></table></figure><p>注意：free不能够释放指向某个确定的数的指针；</p><h5 id="11-2-4-realloc函数"><a href="#11-2-4-realloc函数" class="headerlink" title="11.2.4 realloc函数"></a>11.2.4 realloc函数</h5><p>改变分配的空间的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> size = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">realloc</span>(p, size);<span class="comment">//指针名，size个字节</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;指针和数组&quot;&gt;&lt;a href=&quot;#指针和数组&quot; class=&quot;headerlink&quot; title=&quot;指针和数组&quot;&gt;&lt;/a&gt;指针和数组&lt;/h1&gt;&lt;h3 id=&quot;11-1指针和一维数组的关系&quot;&gt;&lt;a href=&quot;#11-1指针和一维数组的关系&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c中的%（）代表什么--待补充</title>
    <link href="http://example.com/2022/04/25/%E2%80%9Dc%E4%B8%AD%E7%9A%84-%EF%BC%88%EF%BC%89%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E2%80%9C/"/>
    <id>http://example.com/2022/04/25/%E2%80%9Dc%E4%B8%AD%E7%9A%84-%EF%BC%88%EF%BC%89%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E2%80%9C/</id>
    <published>2022-04-25T06:43:46.000Z</published>
    <updated>2022-10-17T13:06:55.783Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%d  用于10进制整数的输入输出</span><br><span class="line">%x  用于12进制整数的输入输出</span><br><span class="line">%o  用于8进制整数的输入输出</span><br><span class="line">%f  用于浮点数的输出（包括double和float）</span><br><span class="line">%lf 用于浮点数的输入</span><br><span class="line">%Lf 用于long double 类型的输入输出</span><br><span class="line">%c  用于字符的输入输出</span><br><span class="line">%p  用于指针的输入输出</span><br><span class="line">%s  用于字符串的输入输出(%8s表示只能输入八个字符，超出的会被分配给下一个scanf，如果没有会被忽略)</span><br><span class="line">一个scanf只能读入一个单词（到空格、tab、回车）为止</span><br></pre></td></tr></table></figure><p>·float只能用%f输入，可用%f或%lf输出<br>·double只能用%lf输入，可用%f或%lf输出<br>·long double只能用%Lf输入，只能用%Lf输出<br>·补充：在进行除法运算时，要注意数字相除是否加小数点，以及分母是否括起来<br>，如果分子分母都没有小数位，需要手动×1.0；<br>最好的解决办法是double sign=1.0；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>“c-第10章字符串”</title>
    <link href="http://example.com/2022/04/25/c-%E7%AC%AC10%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%9D/"/>
    <id>http://example.com/2022/04/25/c-%E7%AC%AC10%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%9D/</id>
    <published>2022-04-25T03:52:11.000Z</published>
    <updated>2022-05-01T12:28:19.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第10章-字符串"><a href="#第10章-字符串" class="headerlink" title="第10章 字符串"></a>第10章 字符串</h1><h3 id="10-1字符串变量"><a href="#10-1字符串变量" class="headerlink" title="10.1字符串变量"></a>10.1字符串变量</h3><pre><code>字符串字面量，也称字符串常量，由双引号括起来的字符序列，例如&quot;Hello&quot;和&quot;123&quot;，无论双引号内有多少个字符，都代</code></pre><p>表一个字符串变量。<br>    需要区分：’a’是字符，”abc”是字符串变量<br>    为了确定字符串变量的长度，字符串末尾会添加一个ASCII值为0的空操作符，’\0’作为字符串结束的标志，其作用等价于0,数组计入0的长度但字符串不计入。故可以在中途加入0使字符串提前结束。</p><h3 id="10-2字符串的储存-字符串的初始化"><a href="#10-2字符串的储存-字符串的初始化" class="headerlink" title="10.2字符串的储存(字符串的初始化)"></a>10.2字符串的储存(字符串的初始化)</h3><p>c里面一般将字符串储存在数组内，但仅当字符型数组末尾的元素为’\0’才表明该数组是字符串数组，’\0’也占用一个字节的长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">6</span>]=&#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">//若忽略对数组长度的的声明，系统会利用提供的初值个数初始化数组的大小</span></span><br><span class="line"><span class="type">char</span> str[]=&#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> str[]=&#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;<span class="comment">//这不是一个字符串数组，只是一个字符型数组</span></span><br><span class="line"><span class="type">char</span> str[]=&#123;<span class="string">&quot;Hello&quot;</span>&#125;;</span><br><span class="line"><span class="type">char</span> str[]=<span class="string">&quot;Hello&quot;</span>;   <span class="comment">//这两种方法所定义的默认为字符串数组，长度为字符数+1</span></span><br></pre></td></tr></table></figure><p>通常将一个字符串放在一维数组中，多个字符串放在二维数组中，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char weekly[][10]&#123;&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturady&quot;,&quot;Sunday&quot;&#125;;</span><br></pre></td></tr></table></figure><p>数组的第一维长度代表字符串的个数，可不填，第二维数组应该设立为最长字符串的长度。</p><p>对于指针指向字符串的初始化写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>*a=<span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure><p>注意：指针直接指向字符串，字符串末尾没有0来多占用一个长度</p><h3 id="10-3-字符指针"><a href="#10-3-字符指针" class="headerlink" title="10.3 字符指针"></a>10.3 字符指针</h3><p>将某个指针指向某个字符串，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *ptr=<span class="string">&quot;Hello&quot;</span>;<span class="comment">//&amp;可加可不加</span></span><br></pre></td></tr></table></figure><p>这种情况下，无法通过改变* par的值对str[0]进行更改。<br>但如果将字符串保存在数组中，可以让一个字符指针指向它。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>]=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> *ptr=str;</span><br></pre></td></tr></table></figure><p>此时可以改变* ptr的值对str[0]进行更改<br>（指针是指向某个字符串，无法对其修改，但数组相当于是说字符串在我这里，这个时候是可以修改的）</p><h3 id="10-4-const-类型限定符"><a href="#10-4-const-类型限定符" class="headerlink" title="10.4 const 类型限定符"></a>10.4 const 类型限定符</h3><p>主要分为两种：<br>①const在* 前面，不可以直接更改指针的值，可以更改指针的指向。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *a=&amp;b;</span><br></pre></td></tr></table></figure><p>但此时可以通过修改b的值更改* a的大小。</p><p>②const在* 后面，可以修改指针的值，但不可以修改指针的指向。[数组a就相当于是一个const在* 后面的指针，无法修改a的指向]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>*<span class="type">const</span> b=&amp;a;</span><br></pre></td></tr></table></figure><h3 id="10-5-字符串的输入"><a href="#10-5-字符串的输入" class="headerlink" title="10.5 字符串的输入"></a>10.5 字符串的输入</h3><p>用一维数组举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>*a[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br></pre></td></tr></table></figure><h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>*<span class="built_in">string</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure><p>以为（因为）char* 是字符串类型，定义了一个字符串类型的string就可以直接用了，但这里的string是没有进行初始化的，所指向的地方并不明确，运行时可能出错。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第10章-字符串&quot;&gt;&lt;a href=&quot;#第10章-字符串&quot; class=&quot;headerlink&quot; title=&quot;第10章 字符串&quot;&gt;&lt;/a&gt;第10章 字符串&lt;/h1&gt;&lt;h3 id=&quot;10-1字符串变量&quot;&gt;&lt;a href=&quot;#10-1字符串变量&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>“c-第9章 指针”</title>
    <link href="http://example.com/2022/04/25/%E2%80%9Cc-%E6%8C%87%E9%92%88%E2%80%9D/"/>
    <id>http://example.com/2022/04/25/%E2%80%9Cc-%E6%8C%87%E9%92%88%E2%80%9D/</id>
    <published>2022-04-25T02:59:44.000Z</published>
    <updated>2022-04-25T14:15:23.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第9章-指针"><a href="#第9章-指针" class="headerlink" title="第9章 指针"></a>第9章 指针</h1><h3 id="9-1-变量的内存地址"><a href="#9-1-变量的内存地址" class="headerlink" title="9.1 变量的内存地址"></a>9.1 变量的内存地址</h3><p>利用取地址符“&amp;”来获取变量的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>,&amp;a);</span><br></pre></td></tr></table></figure><p>我们用%p来输出变量的地址值(以十六进制的无符号整数表现出来)<br>用&amp;作取地址运算符</p><h3 id="9-2-指针变量的定义和初始化"><a href="#9-2-指针变量的定义和初始化" class="headerlink" title="9.2 指针变量的定义和初始化"></a>9.2 指针变量的定义和初始化</h3><p>存放变量的地址需要一种特殊的变量，这种特殊的数据类型就是指针。具有指针类型的变量被称为 指针变量 。<br>指针变量不直接指向某个常数，而是指向某个已知常数值的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a=<span class="literal">NULL</span> <span class="comment">//在不确定指针指向谁的时候，一般定义指针并用NULL对其初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c=<span class="number">1</span>；</span><br><span class="line"><span class="type">int</span> *b=&amp;c；</span><br></pre></td></tr></table></figure><ul><li>b是一个int类型，指向变量c的指针变量，此时由c的地址值对b进行初始化，此时 </li><li>b作为一个整体，它的值为1，它的地址为c的地址，但不能说指针就是地址。</li></ul><h3 id="9-3-按值调用和按引用调用"><a href="#9-3-按值调用和按引用调用" class="headerlink" title="9.3 按值调用和按引用调用"></a>9.3 按值调用和按引用调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Fun</span><span class="params">(<span class="type">int</span> par)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arg = <span class="number">1</span>;</span><br><span class="line">    Fun(arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="type">void</span> <span class="title function_">Fun</span><span class="params">(<span class="type">int</span> par)</span> &#123;</span><br><span class="line">    par = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数Fun里面改变了arg的形参值后，输出实参值，可以发现，实参值并没有发生改变，这是因为传给函数的只是实参值的副本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Fun</span><span class="params">(<span class="type">int</span> *par)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arg = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>*p = &amp;arg;</span><br><span class="line">    Fun(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="type">void</span> <span class="title function_">Fun</span><span class="params">(<span class="type">int</span>*par)</span> &#123;</span><br><span class="line">    *par = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把实参的地址传给形参后，改变形参的地址、值，实参也一样会改变。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第9章-指针&quot;&gt;&lt;a href=&quot;#第9章-指针&quot; class=&quot;headerlink&quot; title=&quot;第9章 指针&quot;&gt;&lt;/a&gt;第9章 指针&lt;/h1&gt;&lt;h3 id=&quot;9-1-变量的内存地址&quot;&gt;&lt;a href=&quot;#9-1-变量的内存地址&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c-第8章  数组和算法基础</title>
    <link href="http://example.com/2022/04/24/c-%E7%AC%AC8%E7%AB%A0%20%E6%95%B0%E7%BB%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/04/24/c-%E7%AC%AC8%E7%AB%A0%20%E6%95%B0%E7%BB%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2022-04-24T12:54:24.000Z</published>
    <updated>2022-05-01T12:28:16.015Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/24/c-%E7%AC%AC8%E7%AB%A0%20%E6%95%B0%E7%BB%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/1.jpg" alt="233">//图片测试</p><h1 id="第8章-数组和算法基础"><a href="#第8章-数组和算法基础" class="headerlink" title="第8章  数组和算法基础"></a>第8章  数组和算法基础</h1><h3 id="8-1数组的定义和初始化"><a href="#8-1数组的定义和初始化" class="headerlink" title="8.1数组的定义和初始化"></a>8.1数组的定义和初始化</h3><h4 id="1-数组的含义"><a href="#1-数组的含义" class="headerlink" title="1.数组的含义"></a>1.数组的含义</h4><p>假定有5个人，需要读取他们的成绩，可以定义以下数组来来存储他们的成绩。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> score[<span class="number">5</span>];    <span class="comment">//此时下标个数为1</span></span><br></pre></td></tr></table></figure><p>该语句定义了：类型、名字和元素个数：有5个元素的一维数组score.<br>（注意：数组的下标都是从0开始的）</p><h4 id="2-数组的定义"><a href="#2-数组的定义" class="headerlink" title="2.数组的定义"></a>2.数组的定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"><span class="type">int</span> b[a];     <span class="comment">//这是错误的表达方式，c89规定在定义数组的时候不能用变量来定义数组的大小，该定义是非法的。只有在c99中才能这么使用。但这并不意味着下标值不能是变量。</span></span><br></pre></td></tr></table></figure><p>②增加宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> a 5; </span></span><br><span class="line"> <span class="type">int</span> b[a]=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">8</span>&#125;<span class="comment">//c99专用，作用同加入const</span></span><br></pre></td></tr></table></figure><p>①在非定义时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span> ;</span><br><span class="line">    <span class="type">int</span> b[]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">85</span>,<span class="number">8</span>&#125;;</span><br><span class="line">     b[a]=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b[i]);</span><br><span class="line">     &#125; <span class="comment">//输出结果为 2 1 85 8</span></span><br></pre></td></tr></table></figure><h4 id="3-数组的初始化-三种方式"><a href="#3-数组的初始化-三种方式" class="headerlink" title="3.数组的初始化(三种方式)"></a>3.数组的初始化(三种方式)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[ ]=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>&#125;; <span class="comment">//系统会利用提供的初值的个数自动初始化数组的长度</span></span><br><span class="line"><span class="type">int</span> c[ ]=&#123;[<span class="number">1</span>]=<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">99</span>]=<span class="number">10</span>&#125;;  <span class="comment">//(c99专用)，对离散型的数据进行赋值</span></span><br></pre></td></tr></table></figure><h4 id="4-数组的元素个数"><a href="#4-数组的元素个数" class="headerlink" title="4.数组的元素个数"></a>4.数组的元素个数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><h3 id="8-2-二位数组的定义和初始化"><a href="#8-2-二位数组的定义和初始化" class="headerlink" title="8.2 二位数组的定义和初始化"></a>8.2 二位数组的定义和初始化</h3><h4 id="1-二维数组一般这么表示"><a href="#1-二维数组一般这么表示" class="headerlink" title="1.二维数组一般这么表示"></a>1.二维数组一般这么表示</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[][<span class="number">2</span>];\\正常定义时，y轴的大小不为<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="2-二维数组的初始化"><a href="#2-二维数组的初始化" class="headerlink" title="2.二维数组的初始化"></a>2.二维数组的初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;,&#123;<span class="number">4</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">5</span>&#125;,&#123;<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>&#125;&#125;;<span class="comment">//两种初始化方式等价,说明,二维数组遍历的顺序应该是按a[0][0] </span></span><br><span class="line"><span class="comment">//a[0][1]的顺序来的</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/24/c-%E7%AC%AC8%E7%AB%A0%20%E6%95%B0%E7%BB%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/1.jpg&quot; alt=&quot;233&quot;&gt;//图片测试&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简单记录一下blog的主题配置</title>
    <link href="http://example.com/2022/04/24/%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8Bblog%E7%9A%84%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2022/04/24/%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8Bblog%E7%9A%84%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</id>
    <published>2022-04-24T08:16:00.000Z</published>
    <updated>2022-04-25T07:51:59.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="blog主题配置的简单记录（butterfly）"><a href="#blog主题配置的简单记录（butterfly）" class="headerlink" title="blog主题配置的简单记录（butterfly）"></a>blog主题配置的简单记录（butterfly）</h1><h3 id="1-位于：blog-config-yml，设置网站个人资料"><a href="#1-位于：blog-config-yml，设置网站个人资料" class="headerlink" title="1.位于：blog_config.yml，设置网站个人资料"></a>1.位于：blog_config.yml，设置网站个人资料</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: Hexo</span><br><span class="line">subtitle: &#x27;&#x27;     //副标题</span><br><span class="line">description: &#x27;&#x27;  //个人说明</span><br><span class="line">keywords:</span><br><span class="line">author: John Doe //作者</span><br><span class="line">language: en</span><br><span class="line">timezone: &#x27;&#x27;     //时区（一般不进行配置）   </span><br></pre></td></tr></table></figure><h3 id="2-位于：blog-themes-XXX-source-config-yml，设置主题配置文件"><a href="#2-位于：blog-themes-XXX-source-config-yml，设置主题配置文件" class="headerlink" title="2.位于：blog\themes\XXX\source_config.yml，设置主题配置文件"></a>2.位于：blog\themes\XXX\source_config.yml，设置主题配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  主页: / || fas fa-home</span><br><span class="line">  博文 || fa fa-graduation-cap:</span><br><span class="line">    分类: /categories/ || fa fa-archive</span><br><span class="line">    标签: /tags/ || fa fa-tags</span><br><span class="line">    归档: /archives/ || fa fa-folder-open</span><br><span class="line">  生活 || fas fa-list:</span><br><span class="line">    分享: /shuoshuo/ || fa fa-comments-o</span><br><span class="line">    相册: /photos/ || fa fa-camera-retro</span><br><span class="line">    音乐: /music/ || fa fa-music</span><br><span class="line">    影视: /movies/ || fas fa-video</span><br><span class="line">  友链: /links/ || fa fa-link</span><br><span class="line">  留言板: /comment/ || fa fa-paper-plane</span><br><span class="line">  #留言板: /messageboard/ || fa fa-paper-plane</span><br><span class="line">  关于笔者: /about/ || fas fa-heart  </span><br></pre></td></tr></table></figure><p>受缩进字符的影响，导航菜单有包含关系。</p><h3 id="3-代码块限制设置"><a href="#3-代码块限制设置" class="headerlink" title="3.代码块限制设置"></a>3.代码块限制设置</h3><p>①位于：blog\themes\XXX\source_config.yml,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">highlight_copy: true   //用于打开代码复制</span><br><span class="line">highlight_shrink: false   //代码框展开，反之不展开</span><br><span class="line">highlight_theme: light   //更改代码高亮主题</span><br></pre></td></tr></table></figure><h3 id="4-创建文件夹"><a href="#4-创建文件夹" class="headerlink" title="4.创建文件夹"></a>4.创建文件夹</h3><p>①分类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>之后会出现source/categories/index.md文件。<br>然后添加type: “categories” layout:”categories”到内容中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2022-04-24 16:16:00</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br></pre></td></tr></table></figure><p>打开需要分类的文章，为其添加categories属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 233</span><br><span class="line">date: 2022-04-24 16:16:00</span><br><span class="line">categories:</span><br><span class="line"> - c     </span><br><span class="line"> - x       \\一片文章只能属于一个分类，hexo会将其分类嵌套，该文章属于c下方的x分类</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>②标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>会出现source/tags/index.md文件：</p><h3 id="5-载入图片"><a href="#5-载入图片" class="headerlink" title="5.载入图片"></a>5.载入图片</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![你想输入的替代文字](xxxx/图片名.jpg)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;blog主题配置的简单记录（butterfly）&quot;&gt;&lt;a href=&quot;#blog主题配置的简单记录（butterfly）&quot; class=&quot;headerlink&quot; title=&quot;blog主题配置的简单记录（butterfly）&quot;&gt;&lt;/a&gt;blog主题配置的简单记录（</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于Git命令</title>
    <link href="http://example.com/2022/04/23/Git%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/04/23/Git%E5%91%BD%E4%BB%A4/</id>
    <published>2022-04-23T04:39:45.204Z</published>
    <updated>2022-09-16T07:10:35.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于Git命令"><a href="#关于Git命令" class="headerlink" title="关于Git命令"></a>关于Git命令</h1><h3 id="新建新文章"><a href="#新建新文章" class="headerlink" title="新建新文章"></a>新建新文章</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n “新文章名称”</span><br></pre></td></tr></table></figure><h3 id="创建新分类"><a href="#创建新分类" class="headerlink" title="创建新分类"></a>创建新分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><h3 id="创建新标签"><a href="#创建新标签" class="headerlink" title="创建新标签"></a>创建新标签</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于Git命令&quot;&gt;&lt;a href=&quot;#关于Git命令&quot; class=&quot;headerlink&quot; title=&quot;关于Git命令&quot;&gt;&lt;/a&gt;关于Git命令&lt;/h1&gt;&lt;h3 id=&quot;新建新文章&quot;&gt;&lt;a href=&quot;#新建新文章&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
  </entry>
  
</feed>
